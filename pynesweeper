#!/usr/bin/python
import curses
from random import randrange

class Square:
    def __init__(self):
        self.has_mine = False
        self.revealed = False
        self.has_flag = False
    @property
    def is_found_mine(self):
        return self.has_mine and self.has_flag
    @property
    def has_erroneous_flag(self):
        return (not self.has_mine) and self.has_flag

class Grid:
    """
    Represents a minesweeper grid. Does not contain any UI info, just the basic
    data model.
    """
    def __init__(self, rows, cols, mines):
        """
        Create a minesweeper Grid, with specified numbers of rows, columns and
        mines.
        """
        self.exploded = False
        self.num_mines = mines
        if mines > rows * cols: raise Exception("Too many mines")
        if rows < 2 or cols < 2: raise Exception("Grid too small")
        self.grid = [[Square() for x in range(cols)] for x in range(rows)]
        self.lay_mines(mines)

    def char_to_show_at(self, row, col):
            if self.grid[row][col].has_flag:
                return "F"
            elif not self.grid[row][col].revealed:
                return "."
            elif self.grid[row][col].has_mine:
                return "*"
            else:
                return str(self.num_adjacent_mines(row, col))

    def lay_mines(self, mines):
        """
        Lay the given number of mines on the Grid.
        """
        indices = [(r, c) for r in range(self.rows) for c in range(self.cols)]
        for x in range(mines):
            rc = indices.pop(randrange(len(indices)))
            self.grid[rc[0]][rc[1]].has_mine = True

    @property
    def rows(self): return len(self.grid)

    @property
    def cols(self): return len(self.grid[0])

    @property
    def num_erroneous_flags(self):
        count = 0
        for each_row in self.grid:
            for square in each_row:
                if square.has_erroneous_flag:
                    count = count + 1
        return count

    @property
    def num_unflagged_mines(self):
        count = self.num_mines
        for each_row in self.grid:
            for square in each_row:
                if square.is_found_mine:
                    count = count - 1
        return count

    def num_adjacent_mines(self, row, col):
        """
        Count the number of mines adjacent to the given (row, col) index.
        """
        return sum(map(lambda rc: self.grid[rc[0]][rc[1]].has_mine, \
                self.adjacent_indices(row, col)))

    def flag_at(self, row, col):
        self.grid[row][col].has_flag = not self.grid[row][col].has_flag

    def step_at(self, row, col):
        if self.grid[row][col].has_flag or self.grid[row][col].revealed:
            return
        elif self.grid[row][col].has_mine:
            self.exploded = True
            self.grid[row][col].revealed = True
        else:
            self.reveal_from(row, col)

    def reveal_from(self, row, col):
        if self.grid[row][col].revealed:
            return
        if self.num_adjacent_mines(row, col) > 0:
            self.grid[row][col].revealed = True
        else:
            self.grid[row][col].revealed = True
            for (rw, cl) in self.adjacent_indices(row, col):
                self.reveal_from(rw, cl)

    def adjacent_indices(self, row, col):
        """
        Given a row and column index, generate the indices of all cells adjacent
        to that index. Raises an error if the given index is outside the grid.
        """
        # Top left corner
        if row == 0 and col == 0:
            return [(row, col + 1), (row + 1, col), (row + 1, col + 1)]
        # Bottom left corner
        elif row == self.rows - 1 and col == 0:
            return [(row - 1, col), (row - 1, col + 1), (row, col + 1)]
        # Top right corner
        elif row == 0 and col == self.cols - 1:
            return [(row, col - 1), (row + 1, col - 1), (row + 1, col)]
        # Bottom right corner
        elif row == self.rows - 1 and col == self.cols - 1:
            return [(row - 1, col - 1), (row - 1, col), (row, col - 1)]
        # Left edge
        elif row > 0 and row < self.rows - 1 and col == 0:
            return [(row - 1, col), (row - 1, col + 1), (row, col + 1), \
                    (row + 1, col), (row + 1, col + 1)]
        # Right edge
        elif row > 0 and row < self.rows - 1 and col == self.cols - 1:
            return [(row - 1, col - 1), (row - 1, col), (row, col - 1), \
                    (row + 1, col - 1), (row + 1, col)]
        # Top edge
        elif row == 0 and col > 0 and col < self.cols - 1:
            return [(row, col - 1), (row, col + 1), (row + 1, col - 1), \
                    (row + 1, col), (row + 1, col + 1)]
        # Bottom edge
        elif row == self.rows - 1 and col > 0 and col < self.cols - 1:
            return [(row - 1, col - 1), (row - 1, col), (row - 1, col + 1), \
                    (row, col - 1), (row, col + 1)]
        # Center area
        elif row > 0 and row < self.rows - 1 and \
                col > 0 and col < self.cols - 1:
            return [(row - 1, col - 1), (row - 1, col), (row - 1, col + 1), \
                    (row, col - 1), (row, col + 1), (row + 1, col - 1), \
                    (row + 1, col), (row + 1, col + 1)]
        else: raise Exception("Index out of range")

    def get_game_status(self):
        if self.exploded:
            return GAME_LOST
        elif self.num_erroneous_flags == 0 and self.num_unflagged_mines == 0:
            return GAME_WON
        else:
            return GAME_IN_PROGRESS


GAME_LOST = 0
GAME_IN_PROGRESS = 1
GAME_WON = 2

def main(stdscr):

    # Init curses
    stdscr.clear()
    curses.noecho()
    curses.cbreak()
    curses.start_color()
    curses.use_default_colors()
    stdscr.keypad(True)

    # Colors
    curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)
    curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_RED)

    cursor_row = 0
    cursor_col = 0
    the_grid = Grid(10, 10, 12)
    paint(stdscr, the_grid, cursor_row, cursor_col)

    while True:
        char = stdscr.getch()
        if char == curses.KEY_LEFT:
            if cursor_col > 0: cursor_col = cursor_col - 1
        elif char == curses.KEY_RIGHT:
            if cursor_col < the_grid.cols - 1: cursor_col = cursor_col + 1
        elif char == curses.KEY_UP:
            if cursor_row > 0: cursor_row = cursor_row - 1
        elif char == curses.KEY_DOWN:
            if cursor_row < the_grid.rows - 1: cursor_row = cursor_row + 1
        elif char == ord(' '):
            the_grid.flag_at(cursor_row, cursor_col)
        elif char == ord('\n'):
            the_grid.step_at(cursor_row, cursor_col)
        elif char == ord('q'):
            break
        else:
            1# Do nothing
        paint(stdscr, the_grid, cursor_row, cursor_col)

    # Deinit curses
    curses.nocbreak()
    stdscr.keypad(False)
    curses.echo()
    curses.endwin()

def paint(stdscr, grid, cursor_row, cursor_col):
    stdscr.clear()
    status = grid.get_game_status()
    if status == GAME_LOST:
        stdscr.addstr(1, 1, "============", curses.color_pair(1))
        stdscr.addstr(2, 1, "= YOU LOSE =", curses.color_pair(1))
        stdscr.addstr(3, 1, "============", curses.color_pair(1))
    elif status == GAME_IN_PROGRESS:
        for row in range(grid.rows):
            for col in range(grid.cols):
                if cursor_row == row and cursor_col == col:
                    stdscr.addstr(row, col, grid.char_to_show_at(row, col), \
                            curses.color_pair(2))
                else:
                    stdscr.addstr(row, col, grid.char_to_show_at(row, col), \
                            curses.color_pair(1))
    else:
        stdscr.addstr(1, 1, "============", curses.color_pair(1))
        stdscr.addstr(2, 1, "= YOU WIN! =", curses.color_pair(1))
        stdscr.addstr(3, 1, "============", curses.color_pair(1))
    stdscr.refresh()

if __name__ == "__main__":
    curses.wrapper(main)
