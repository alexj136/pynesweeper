#!/usr/bin/python
import curses
from random import randrange

class Square:
    def __init__(self):
        self.has_mine = False
        self.revealed = False
    def place_mine(self):
        self.has_mine = True

class Grid:
    """
    Represents a minesweeper grid. Does not contain any UI info, just the basic
    data model.
    """
    def __init__(self, rows, cols, mines):
        """
        Create a minesweeper Grid, with specified numbers of rows, columns and
        mines.
        """
        if mines > rows * cols: raise Exception("Too many mines")
        if rows < 2 or cols < 2: raise Exception("Grid too small")
        self.grid = [[Square() for x in range(cols)] for x in range(rows)]
        self.lay_mines(mines)

    def lay_mines(self, mines):
        """
        Lay the given number of mines on the Grid.
        """
        indices = [(r, c) for r in range(self.rows) for c in range(self.cols)]
        for x in range(mines):
            index = randrange(len(indices))
            self.grid[indices[index][0]][indices[index][1]].has_mine = True
            indices.remove(index)

    @property
    def rows(self): return len(self.grid)

    @property
    def cols(self): return len(self.grid[0])

    def __str__(self):
        output = ""
        for row_no in range(len(self.grid)):
            line = ""
            for col_no in range(len(self.grid[0])):
                line = line + (" " if not self.grid[row_no][col_no].revealed \
                        else ("*" if self.grid[row_no][col_no].has_mine
                        else str(self.num_adjacent_mines(row_no, col_no))))
            output = output + line + "\n"
        return output

    def num_adjacent_mines(self, row, col):
        """
        Count the number of mines adjacent to the given (row, col) index.
        """
        return sum(map(lambda rc: self.grid[rc[0], rc[1]].has_mine, \
                adjacent_indices(row, col)))

    def step(self, row, col):
        if not (self.grid[row][col].revealed or self.grid[row][col].has_mine):
            self.grid[row][col].revealed = True
            for (rw, cl) in self.adjacent_indices(row, col):
                self.step(rw, cl)
        return

    def adjacent_indices(self, row, col):
        """
        Given a row and column index, generate the indices of all cells adjacent
        to that index. Raises an error if the given index is outside the grid.
        """
        # Top left corner
        if row == 0 and col == 0:
            return [(row, col + 1), (row + 1, col), (row + 1, col + 1)]
        # Bottom left corner
        elif row == self.rows - 1 and col == 0:
            return [(row - 1, col), (row - 1, col + 1), (row, col + 1)]
        # Top right corner
        elif row == 0 and col == self.cols - 1:
            return [(row, col - 1), (row + 1, col - 1), (row + 1, col)]
        # Bottom right corner
        elif row == self.rows - 1 and col == self.cols - 1:
            return [(row - 1, col - 1), (row - 1, col), (row, col - 1)]
        # Left edge
        elif row > 0 and row < self.rows - 1 and col == 0:
            return [(row - 1, col), (row - 1, col + 1), (row, col + 1), \
                    (row + 1, col), (row + 1, col + 1)]
        # Right edge
        elif row > 0 and row < self.rows - 1 and col == self.cols - 1:
            return [(row - 1, col - 1), (row - 1, col), (row, col - 1), \
                    (row + 1, col - 1), (row + 1, col)]
        # Top edge
        elif row == 0 and col > 0 and col < self.cols - 1:
            return [(row, col - 1), (row, col + 1), (row + 1, col - 1), \
                    (row + 1, col), (row + 1, col + 1)]
        # Bottom edge
        elif row == self.rows - 1 and col > 0 and col < self.cols - 1:
            return [(row - 1, col - 1), (row - 1, col), (row - 1, col + 1), \
                    (row, col - 1), (row, col + 1)]
        # Center area
        elif row > 0 and row < self.rows - 1 and \
                col > 0 and col < self.cols - 1:
            return [(row - 1, col - 1), (row - 1, col), (row - 1, col + 1), \
                    (row, col - 1), (row, col + 1), (row + 1, col - 1), \
                    (row + 1, col), (row + 1, col + 1)]
        else: raise Exception("Index out of range")

def main(stdscr):

    # Init curses
    stdscr.clear()
    curses.noecho()
    curses.cbreak()
    stdscr.keypad(True)

    cursor_row = 0
    cursor_col = 0

    the_grid = Grid(6, 5, 1)
    the_grid.step(2,3)
    stdscr.addstr(0, 0, str(the_grid))
    stdscr.refresh()

    char = stdscr.getch()
    while True:
        char = stdscr.getch()
        if char == curses.KEY_LEFT:
            cursor_col = cursor_col - 1
        elif char == curses.KEY_RIGHT:
            cursor_col = cursor_col + 1
        elif char == curses.KEY_UP:
            cursor_row = cursor_row - 1
        elif char == curses.KEY_DOWN:
            cursor_row = cursor_row + 1
        else:
            break

    # Deinit curses
    curses.nocbreak()
    stdscr.keypad(False)
    curses.echo()
    curses.endwin()

if __name__ == "__main__":
    curses.wrapper(main)
