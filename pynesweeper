#!/usr/bin/python
import curses
import random

class Square:
    def __init__(self):
        self.has_mine = False
        self.revealed = False
    def place_mine(self):
        self.has_mine = True

class Grid:
    """
    Represents a minesweeper grid. Does not contain any UI info, just the basic
    data model.
    """
    def __init__(self, rows, cols, mines):
        """
        Create a minesweeper Grid, with specified numbers of rows, columns and
        mines.
        """
        if mines > rows * cols: raise Exception("Too many mines")
        if rows < 2 or cols < 2: raise Exception("Grid too small")
        self.grid = [[Square() for x in range(cols)] for x in range(rows)]
        self.lay_mines(mines)

    def lay_mines(self, mines):
        """
        Lay the given number of mines on the Grid.
        """
        if mines == 0: return
        rand_row = random.randint(0, len(self.grid) - 1)
        rand_col = random.randint(0, len(self.grid[0]) - 1)
        if self.grid[rand_row][rand_col].has_mine:
            self.lay_mines(mines)
        else:
            self.grid[rand_row][rand_col].has_mine = True
            self.lay_mines(mines - 1)

    @property
    def rows(self): return len(self.grid)

    @property
    def cols(self): return len(self.grid[0])

    def __str__(self):
        output = ""
        for row_no in range(len(self.grid)):
            line = ""
            for col_no in range(len(self.grid[0])):
                line = line + (" " if not self.grid[row_no][col_no].revealed \
                        else ("*" if self.grid[row_no][col_no].has_mine
                        else str(self.num_adjacent_mines(row_no, col_no))))
            output = output + line + "\n"
        return output

    def adjacent_indices(self, row, col):
        """
        Given a row and column index, generate the indices of all cells adjacent
        to that index. Raises an error if the given index is outside the grid.
        """
        # Top left corner
        if row == 0 and col == 0:
            return [(row, col + 1), (row + 1, col), (row + 1, col + 1)]
        # Bottom left corner
        elif row == self.rows - 1 and col == 0:
            return [(row - 1, col), (row - 1, col + 1), (row, col + 1)]
        # Top right corner
        elif row == 0 and col == self.cols - 1:
            return [(row, col - 1), (row + 1, col - 1), (row + 1, col)]
        # Bottom right corner
        elif row == self.rows - 1 and col == self.cols - 1:
            return [(row - 1, col - 1), (row - 1, col), (row, col - 1)]
        # Left edge
        elif row > 0 and row < self.rows - 1 and col == 0:
            return [(row - 1, col), (row - 1, col + 1), (row, col + 1), \
                    (row + 1, col), (row + 1, col + 1)]
        # Right edge
        elif row > 0 and row < self.rows - 1 and col == self.cols - 1:
            return [(row - 1, col - 1), (row - 1, col), (row, col - 1), \
                    (row + 1, col - 1), (row + 1, col)]
        # Top edge
        elif row == 0 and col > 0 and col < self.cols - 1:
            return [(row, col - 1), (row, col + 1), (row + 1, col - 1), \
                    (row + 1, col), (row + 1, col + 1)]
        # Bottom edge
        elif row == self.rows - 1 and col > 0 and col < self.cols - 1:
            return [(row - 1, col - 1), (row - 1, col), (row - 1, col + 1), \
                    (row, col - 1), (row, col + 1)]
        # Center
        elif row > 0 and row < self.rows - 1 and \
                col > 0 and col < self.cols - 1:
            return [(row - 1, col - 1), (row - 1, col), (row - 1, col + 1), \
                    (row, col - 1), (row, col + 1), (row + 1, col - 1), \
                    (row + 1, col), (row + 1, col + 1)]
        else: raise Exception("Index out of range")

    def num_adjacent_mines(self, row, col):
        # Top left corner
        if row == 0 and col == 0:
            return sum(map(lambda c: c.has_mine, [ \
                    self.grid[row][col + 1], \
                    self.grid[row + 1][col], \
                    self.grid[row + 1][col + 1]]))
        # Bottom left corner
        elif row == self.rows - 1 and col == 0:
            return sum(map(lambda c: c.has_mine, [ \
                    self.grid[row - 1][col], \
                    self.grid[row - 1][col + 1], \
                    self.grid[row][col + 1]]))
        # Top right corner
        elif row == 0 and col == self.cols - 1:
            return sum(map(lambda c: c.has_mine, [ \
                    self.grid[row][col - 1], \
                    self.grid[row + 1][col - 1], \
                    self.grid[row + 1][col]]))
        # Bottom right corner
        elif row == self.rows - 1 and col == self.cols - 1:
            return sum(map(lambda c: c.has_mine, [ \
                    self.grid[row - 1][col - 1], \
                    self.grid[row - 1][col], \
                    self.grid[row][col - 1]]))
        # Left edge
        elif row > 0 and row < self.rows - 1 and col == 0:
            return sum(map(lambda c: c.has_mine, [ \
                    self.grid[row - 1][col], \
                    self.grid[row - 1][col + 1], \
                    self.grid[row][col + 1], \
                    self.grid[row + 1][col], \
                    self.grid[row + 1][col + 1]]))
        # Right edge
        elif row > 0 and row < self.rows - 1 and col == self.cols - 1:
            return sum(map(lambda c: c.has_mine, [ \
                    self.grid[row - 1][col - 1], \
                    self.grid[row - 1][col], \
                    self.grid[row][col - 1], \
                    self.grid[row + 1][col - 1], \
                    self.grid[row + 1][col]]))
        # Top edge
        elif row == 0 and col > 0 and col < self.cols - 1:
            return sum(map(lambda c: c.has_mine, [ \
                    self.grid[row][col - 1], \
                    self.grid[row][col + 1], \
                    self.grid[row + 1][col - 1], \
                    self.grid[row + 1][col], \
                    self.grid[row + 1][col + 1]]))
        # Bottom edge
        elif row == self.rows - 1 and col > 0 and col < self.cols - 1:
            return sum(map(lambda c: c.has_mine, [ \
                    self.grid[row - 1][col - 1], \
                    self.grid[row - 1][col], \
                    self.grid[row - 1][col + 1], \
                    self.grid[row][col - 1], \
                    self.grid[row][col + 1]]))
        # Center
        elif row > 0 and row < self.rows - 1 and \
                col > 0 and col < self.cols - 1:
                return sum(map(lambda c: c.has_mine, [ \
                    self.grid[row - 1][col - 1], \
                    self.grid[row - 1][col], \
                    self.grid[row - 1][col + 1], \
                    self.grid[row][col - 1], \
                    self.grid[row][col + 1], \
                    self.grid[row + 1][col - 1], \
                    self.grid[row + 1][col], \
                    self.grid[row + 1][col + 1]]))
        else: raise Exception("Index out of range")

    def step(self, row, col):
        if self.grid[row][col].revealed or self.grid[row][col].has_mine: return
        else:
            self.grid[row][col].revealed = True
            # Top left corner
            if row == 0 and col == 0:
                self.step(row, col + 1)
                self.step(row + 1, col)
                self.step(row + 1, col + 1)
            # Bottom left corner
            elif row == self.rows - 1 and col == 0:
                self.step(row - 1, col)
                self.step(row - 1, col + 1)
                self.step(row, col + 1)
            # Top right corner
            elif row == 0 and col == self.cols - 1:
                self.step(row, col - 1)
                self.step(row + 1, col - 1)
                self.step(row + 1, col)
            # Bottom right corner
            elif row == self.rows - 1 and col == self.cols - 1:
                self.step(row - 1, col - 1)
                self.step(row - 1, col)
                self.step(row, col - 1)
            # Left edge
            elif row > 0 and row < self.rows - 1 and col == 0:
                self.step(row - 1, col)
                self.step(row - 1, col + 1)
                self.step(row, col + 1)
                self.step(row + 1, col)
                self.step(row + 1, col + 1)
            # Right edge
            elif row > 0 and row < self.rows - 1 and col == self.cols - 1:
                self.step(row - 1, col - 1)
                self.step(row - 1, col)
                self.step(row, col - 1)
                self.step(row + 1, col - 1)
                self.step(row + 1, col)
            # Top edge
            elif row == 0 and col > 0 and col < self.cols - 1:
                self.step(row, col - 1)
                self.step(row, col + 1)
                self.step(row + 1, col - 1)
                self.step(row + 1, col)
                self.step(row + 1, col + 1)
            # Bottom edge
            elif row == self.rows - 1 and col > 0 and col < self.cols - 1:
                self.step(row - 1, col - 1)
                self.step(row - 1, col)
                self.step(row - 1, col + 1)
                self.step(row, col - 1)
                self.step(row, col + 1)
            # Center
            elif row > 0 and row < self.rows - 1 and \
                    col > 0 and col < self.cols - 1:
                self.step(row - 1, col - 1)
                self.step(row - 1, col)
                self.step(row - 1, col + 1)
                self.step(row, col - 1)
                self.step(row, col + 1)
                self.step(row + 1, col - 1)
                self.step(row + 1, col)
                self.step(row + 1, col + 1)
            else: raise Exception("Index out of range")

def main(stdscr):

    # Init curses
    stdscr.clear()
    curses.noecho()
    curses.cbreak()
    stdscr.keypad(True)

    cursor_row = 0
    cursor_col = 0

    the_grid = Grid(6, 5, 1)
    the_grid.step(2,3)
    stdscr.addstr(0, 0, str(the_grid))
    stdscr.refresh()

    char = stdscr.getch()
    while True:
        char = stdscr.getch()
        if char == curses.KEY_LEFT:
            cursor_col = cursor_col - 1
        elif char == curses.KEY_RIGHT:
            cursor_col = cursor_col + 1
        elif char == curses.KEY_UP:
            cursor_row = cursor_row - 1
        elif char == curses.KEY_DOWN:
            cursor_row = cursor_row + 1
        else:
            break

    # Deinit curses
    curses.nocbreak()
    stdscr.keypad(False)
    curses.echo()
    curses.endwin()

curses.wrapper(main)
exit()
